package POF_Resolute
public
	annex Resolute {**

	-- elements have a response time: 
	has_Response_Time(cp: aadl)<=
	** cp " must have a response time specified" **
		has_property(cp, Communication_Properties::Latency)
	-- used for sensor, process, actuator -- delegate to ALISA
	
	-- end-to-end latency is w/in specified bound
	
	
	
	has_connection_end_types(c: component) <=
	** "All connection ends in " c " must have a type declared" **
		-- This may have to be custom-written: there's some good
		-- connection utility stuff in Resolute_Util.aadl, though
		-- but the basic idea is to iterate over the connections from
		-- all_reachable_connections and then check each end to verify typing.
		
		
	-- Copied from Connectivity_Reachability.aadl  
	--### all_reachable_connections(c : component) : {connection}
	--. Return all port, data, bus access connections that are traversed when identifying reachable components
	--. we consider direct and indirect reachability
	all_reachable_connections(c : component) : {connection} =
		recursive_visited_connections({c})
	
	-- support method to expand on a set of visited connections in recrusive traversal
	recursive_visited_connections(curr: {component}) : {connection} =
		let outconns : {connection} = outgoing_component_connections(comp); -- XXX wrongm cannot be comp
		let next_ones : {component} = {otherend for (conn: outconns) (otherend: other_connection_end(conn,comp))};
		let next_new_ones : {component} = {ele for (ele : next_ones)| not(member(ele,curr))};
		if (next_new_ones = {}) then
			{}
		else
			union(outconns, recursive_visited_connections(next_new_ones))
	
	**};
end POF_Resolute;